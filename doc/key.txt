# 对象通用 key
[object].var:
	定义变量，在 [object] 下
	var type:varname[ [length] ][ = value ][ , type:varname[ [length] ][ = value ] ... ] ;
	type:
		void
		byte,sbyte,ubyte
		word,sword,uword
		int,sint,uint
		long,slong,ulong
		float
		string
		vlist,vmat
	length:
		可为表达式，但当 type == vlist||vmat 时暂不能定义数组
	value:
		变量初值，可为表达式
	varname:
		变量标识符，应由 [_a-zA-z0-9] 组成，数字不能开头；
		每个对象内不能有重名变量，另外变量名称不能为预留名称（即 .gobj 对象内的子变量名称）
	另外，定义变量需要有足够权限，即 [object] 必须有 write 权限
	可以重复定义变量，以此更改变量类型，但目标变量必须拥有 retype 权限，更改类型后不改变变量权限
	变量初始类型为 srwl--
[object].delete:
	删除变量，在 [object] 下
	delete varname[ , ... ];
	删除 [object].varname 和其子项（如果有的话）
	显式删除变量需要该变量拥有 link 权限
[object].function:
	定义对象函数，在 [object] 下
	function type:funcname([argvname:argvtype [, ...] ]) [{code}];
	funcname:
		函数名称，规范同 varname
	type:
		函数返回值类型，可为处数组之外的其他变量类型；
		但数组类型仍可作为函数返回值，需要对 [function]._ret_ (srw---) 重定义
	argvname:
		传递参数名称，同变量名
	argvtype:
		该变量可接受的类型，可从 .type.* 获取和或运算，具体类型由传入变量类型决定
		变量传入以硬链接方式进行，没有中间副本
	code:
		脚本代码，可无，可修改 [function]._text_ 达到修改函数的目的
		若无 code ，即 [function]._text_ 为空字符串，函数不会执行，但传参前的参数计算照常
# 全局变量 key
.goto:
	从开头寻找跳转
	.goto label;
	label:
		标签，应由 [_a-zA-z0-9] 组成，数字不能开头；
		标签的定义为在一行开头 #label;
		'#' 与 label 中间不能有其他符号（包括空白符），label 后应有 ';'；
.gotodw:
	从当前位置向下寻找跳转
	.gotodw label;
.gotoup:
	从当前位置向上寻找跳转
	.gotoup label;
.if:
	判断执行
	.if exp; action;
	exp:
	action:
		均为表达式
	如果 exp 结果为真，则运算 action
	否则跳过 action
	PS:
		可用 .gotodw 来达到近似于 if () {} 的效果
		.if !(exp); .gotodw endif;
		action;
		#endif;
.while:
	循环执行
	.while exp; action;
	如果 exp 为真，则执行 action ，直到 exp 不为真，跳过 action
.exit:
	无条件退出
	.exit [action];
	[执行 action 后，]退出当前环境
	在全局范围内 .exit 等价于结束程序，在函数内等价于函数返回（[function]._ret_）

